#!/bin/bash
set -euo pipefail

# Usage: tmux-worktree <git-worktree-root> <tmuxp-layout-yaml>
# <git-worktree-root> is the bare repo (or directory containing worktrees/)
# <tmuxp-layout-yaml> path to a tmuxp layout yaml file
# Example: tmux-worktree /path/to/bare/repo ~/scripts/layouts/kraken-worktree.yaml

if [ $# -lt 2 ]; then
  echo "Usage: $(basename "$0") <git-worktree-root> <tmuxp-layout-yaml>" >&2
  exit 1
fi

GIT_ROOT=$1
LAYOUT_FILE=$2
WORKTREE_SEARCH_DIR="$GIT_ROOT/worktrees"

# Expand leading ~/ in layout path without using eval
case "$LAYOUT_FILE" in
  ~/*) LAYOUT_FILE="$HOME/${LAYOUT_FILE#~/}" ;;
esac

if [ ! -d "$GIT_ROOT" ]; then
  echo "Error: path '$GIT_ROOT' does not exist." >&2
  exit 1
fi

if [ ! -d "$WORKTREE_SEARCH_DIR" ]; then
  echo "Error: worktrees directory not found; git repo is not a bare repo." >&2
  exit 1
fi

if [ ! -f "$LAYOUT_FILE" ]; then
  echo "Error: layout file '$LAYOUT_FILE' not found." >&2
  exit 1
fi

if [ -z "${TMUX_CONFIG:-}" ]; then
  echo "Error: TMUX_CONFIG is not set. Exiting." >&2
  exit 1
fi

# List existing worktree directories
EXISTING_DIRS=$(find "$WORKTREE_SEARCH_DIR" -mindepth 1 -maxdepth 1 -type d -exec basename {} \; | sort -u)

# fzf: allow typing a new branch name not yet a worktree
RAW=$(printf '%s\n' "$EXISTING_DIRS" | fzf --prompt="Select or type branch: " --print-query --preview='SEL={}; if [ -n "$SEL" ]; then ls -l "$WORKTREE_SEARCH_DIR/$SEL" 2>/dev/null || echo "(new)"; fi' --preview-window=up:5 || true)
QUERY=$(printf '%s' "$RAW" | sed -n '1p')
CHOICE=$(printf '%s' "$RAW" | sed -n '$p')

BRANCH_NAME=""
IS_EXISTING=0
if [ -n "$CHOICE" ] && printf '%s\n' "$EXISTING_DIRS" | grep -Fxq "$CHOICE"; then
  BRANCH_NAME="$CHOICE"
  IS_EXISTING=1
else
  BRANCH_NAME="$QUERY"
fi

# Abort if nothing entered
if [ -z "$BRANCH_NAME" ]; then
  echo "No input provided. Exiting." >&2
  exit 1
fi

# Normalize (strip CR)
BRANCH_NAME=$(printf '%s' "$BRANCH_NAME" | tr -d '\r')

# Validate new branch names (skip validation for existing dir names beyond emptiness)
if [ $IS_EXISTING -eq 0 ]; then
  if printf '%s' "$BRANCH_NAME" | grep -q '[[:space:]]'; then
    echo "Error: branch name may not contain spaces." >&2; exit 1; fi
  if printf '%s' "$BRANCH_NAME" | grep -q '^/'; then
    echo "Error: branch name may not start with /." >&2; exit 1; fi
fi

if [ $IS_EXISTING -eq 1 ]; then
  SESSION_NAME="$BRANCH_NAME"
  WORKTREE_PATH="$GIT_ROOT/$SESSION_NAME"
else
  SESSION_NAME=${BRANCH_NAME//\//_}
  WORKTREE_PATH="$GIT_ROOT/$SESSION_NAME"
fi

# Determine default branch dynamically
DEFAULT_BRANCH="${DEFAULT_BRANCH:-}"
if [ -z "$DEFAULT_BRANCH" ]; then
  if origin_head_ref=$(git -C "$GIT_ROOT" symbolic-ref --quiet refs/remotes/origin/HEAD 2>/dev/null); then
    DEFAULT_BRANCH=${origin_head_ref##*/}
  else
    remote_head=$(git -C "$GIT_ROOT" remote show origin 2>/dev/null | awk '/HEAD branch/ {print $NF}') || true
    if [ -n "${remote_head:-}" ]; then
      DEFAULT_BRANCH="$remote_head"
    elif git -C "$GIT_ROOT" show-ref --verify --quiet refs/heads/main; then
      DEFAULT_BRANCH=main
    else
      DEFAULT_BRANCH=master
    fi
  fi
fi

if [ -d "$WORKTREE_PATH" ]; then
  cd "$WORKTREE_PATH"
else
  cd "$GIT_ROOT"
  echo "Preparing worktree for branch: $BRANCH_NAME"
  if git ls-remote --exit-code --heads origin "$BRANCH_NAME" >/dev/null 2>&1; then
    if git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
      git worktree add "$WORKTREE_PATH" "$BRANCH_NAME"
    else
      git worktree add -b "$BRANCH_NAME" "$WORKTREE_PATH" "origin/$BRANCH_NAME"
    fi
  else
    echo "Remote branch not found; creating from $DEFAULT_BRANCH"
    git worktree add "$WORKTREE_PATH" -b "$BRANCH_NAME" "$DEFAULT_BRANCH"
  fi
fi

GIT_WORKTREE=$SESSION_NAME tmuxp load "$LAYOUT_FILE"
